# -*- coding: utf-8 -*-
"""A Review of Liver Patient Analysis Methods using Machine Learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jhrv4C18_b5cBE0atrE6bcTIY7Co5mVO
"""

1
2 import pandas as pd
3 import numpy as np
4 import seaborn as sns
5 import matplotlib.pyplot as plt
6 from matplotlib import rcParams
from scipy import stats

#import the dataset from specified Location data = pd.read_csv('E:/Datascience/Datasets/indian_liver_patient.csv')

#showing the data from top 5
data.head()

data.info()

data.isnull().any()

data.isnull().sum()

#checking for the missing data after cleaning data
data['Albumin_and_Globulin_Ratio'] = data.fillna (data['Albumin_and_Globulin_Ratio'].mode()[0])
data.isnull().sum()

from sklearn.preprocessing import LabelEncoder 2 lc LabelEncoder() 3 data['gender']= lc.fit_transform(data['gender'])

2
3 data.describe()

1 sns.distplot(data['age'])
2 plt.title('Age Distribution Graph
3 plt.show()

1 sns.countplot(data['outcome'], hue=data['gender']) 2

1 plt.figure(figsize=(10,7))
2 3 sns.heatmap(df.corr(), annot=True)
<AxesSubplot:>

1 from sklearn.preprocessing import scale
2 x_scaled=pd.DataFrame (scale (X), columns=X.columns)
1 X_scaled.head()

X=data.iloc[:,:-1] 2 y=data.outcome

1 from sklearn.model_selection import train_test_split 3 X_train, X_test, y_train, y_test = train_test_split(x_scaled,y, test_size=0.2, random_state=42

1 pip install imblearn

1 from imblearn.over_sampling import SMOTE
2
smote = SMOTE()

y_train.value_counts()

1 X_train_smote, y_train_smote smote.fit_resample (X_train, y_train)

y_train_smote.value_counts()

1 from sklearn.ensemble import RandomForestClassifier
2 model1=RandomForestClassifier()
3 model1.fit(x_train_smote, y_train_smote)
4 y_predict=model1.predict(x_test)
5 rfc1-accuracy_score (y_test,y_predict)
6 rfc1
7 pd.crosstab (y_test, y_predict)
8 print(classification_report (y_test, y_predict))

from sklearn.tree import Decision TreeClassifier model4-Decision TreeClassifier()
model4.fit(X_train_smote, y_train_smote) y_predict=model4.predict(x_test)
dtc1-accuracy_score (y_test,y_predict) dtc1
pd.crosstab(y_test,y_predict)
print(classification_report (y_test, y_predict))

from sklearn.neighbors import KNeighborsClassifier model2=KNeighborsClassifier()
model2.fit(X_train_smote, y_train_smote) y_predict = model2.predict(x_test)
knn1=(accuracy_score (y_test, y_predict)) knn1
pd.crosstab(y_test,y_predict)
print(classification_report (y_test, y_predict))

from sklearn.linear_model import Logistic Regression model5=LogisticRegression()
model5.fit(x_train_smote, y_train_smote) y_predict=model5.predict(x_test)
logi1=accuracy_score (y_test, y_predict)
logil
pd.crosstab(y_test,y_predict)
print (classification_report (y_test, y_predict))

1 import tensorflow.keras
2 from tensorflow.keras.models import Sequential 3 from tensorflow.keras.layers import Dense

1 # Initialising the ANN
2 classifier = Sequential()

1 # Adding the input layer and the first hidden layer
2 classifier.add(Dense (units=100, activation='relu', input_dim=10))

1 # Adding the second hidden Layer
2 classifier.add(Dense (units=50, activation='relu'))

1 # Adding the output layer
2 classifier.add(Dense (units=1, activation='sigmoid'))

1 # Compiling the ANN
2 classifier.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

1 # Fitting the ANN to the Training set
2 model_history = classifier.fit(x_train, y_train, batch_size=100, validation_split =0.2, epochs=100)

1 #Age Gender Total Bilrubin "Direct Bilrubin Alkaline Phosphotase 2 model4.predict([[50,1,1.2,0.8,150,70,80,7.2,3.4,0.8])
Alanin_Aminotransferase
Asparate_Aminotrans

#Age Gender Total_Bilrubin "Direct_Bilrubin Alkaline Phosphotase 2 model1.predict([[50,1,1.2,0.8,150,70,80,7.2,3.4,0.8]) "Alanin_Aminotransferase Asparate_Aminotrans

1 #Age Gender Total_Bilrubin Direct_Bilrubin Alkaline Phosphotase- 2 model2.predict([[50,1,1.2,0.8,150,70,80,7.2,3.4,0.8]]) â†’Alanin_Aminotransferase Asparate_Aminotrans_

1 #Age Gender Total_Bilrubin Direct_Bilrubin Alkaline Phosphotase "Alanin_Aminotransferase Asparate_Aminotrans
2 mode15.predict([[42,0,1.2,0.8,240,70,80,7.2,3.4,0.8]])

y_pred = (y_pred > 0.5) y_pred

1 def predict_exit(sample_value):
12345
2
3
# Convert list to numpy array
4 sample_value = np.array (sample_value)
5
# Reshape because sample_value contains only 1 record sample_value = sample_value.reshape(1, -1)
6789
# Feature Scaling
10
sample_value = scale(sample_value)
11
12
return classifier.predict(sample_value)
1 #Age Gender Total_Bilrubin Direct_Bilrubin Alkaline Phosphotase
2 sample_value = [[50,1,1.2,0.8,150,70,80,7.2,3.4,0.8]]
3 if predict_exit (sample_value)>0.5: 4 print('Prediction: Liver Patient')
5
6
else:
print('Prediction: Healthy ')

1 acc_smote= [['KNN Classifier', knn1], ['RandomForestClassifier', rfc1], ['DecisionTreeClassifier', dtc1], ['Logistic Regression', logi1]]
2
3 Liverpatient_pred= pd.DataFrame (acc_smote, columns = ['classification models', 'accuracy_score'])
4 Liverpatient_pred

1 2 plt.xticks(rotation=90)
3 plt.title('Classification models & accuracy scores after SMOTE', fontsize=18) 4 sns.barplot(x="classification models", y="accuracy_score", data=Liverpatient_pred, palette ="Set2")

1 from sklearn.ensemble import ExtraTreesClassifier
2 model-ExtraTreesClassifier()
3 model.fit(x,y)

model.feature_importances

1 dd=pd.DataFrame (model.feature_importances_, index-X.columns).sort_values(0, ascending=False) 2 dd

1 dd.plot(kind='barh', figsize=(7,6)) 2 plt.title("FEATURE IMPORTANCE", fontsize=14)
Text(0.5, 1.0, 'FEATURE IMPORTANCE')

1 import joblib 2 joblib.dump (model1, ETC.pk1')

from flask import Flask, render_template, request
import numpy as np
import pickle

app=Flask (__name_ # our flask app
@app.route('/') # rendering the html template
def home():
return render_template('home.html')
@app.route('/predict') # rendering the html template
def index() :
return render_template("index.html")

@app.route('/data_predict', methods=['POST']) # route for our prediction def predict():
age = request.form['age'] # requesting for age data
gender = request.form['gender'] # requesting for gender data
tb = request.form['tb'] # requesting for Total Bilirubin data
db = request.form['db'] # requesting for Direct Bilirubin data
ap = request.form['ap'] # requesting for Alkaline Phosphotose data
aal = request.form['aal'] # requesting for Alamine Aminotransferase data
aa2 = request.form['aa2'] # requesting for Aspartate Aminotransferase data tp = request.form['tp'] # requesting for Total_Protiens data
a = request.form['a'] # requesting for Albumin data
agr = request.form['agr'] # requesting for Albumin and Globulin Ratio data
#coverting data into float format
data = [[float(age), float (gender), float(tb), float(db), float (ap), float (aal), float (aa2), float(tp),
# Loading model which we saved
model = pickle.load(open('liver_analysis.pkl', 'rb'))
prediction= model.predict(data)[0]
if (prediction == 1):
return render_template('noChance.html', prediction='You have a liver desease problem, You must and
else:
return render_template('chance.html', prediction='You dont have a liver desease problem')
if __name__ == '__main__':
app.run()

if_name_ app.run() '__main__':

pase) D:\TheSmartBridge\Projects \2. DrugClassification\Drug * Serving Flask app "app" (lazy loading) Environment: production
WARNING: This is a development server. Do not use it in a p
Use a production WSGI server instead.
Debug mode: off
Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)